"""
Шаблоны промптов для различных агентов.
"""

from typing import Dict, Any, List


class PromptTemplates:
    """Класс с шаблонами промптов для агентов."""
    
    @staticmethod
    def system_prompt() -> str:
        """Системный промпт для главного агента."""
        return """Ты - автономный AI-агент для управления веб-браузером. Твоя задача - выполнять сложные многошаговые задачи в браузере.

КЛЮЧЕВЫЕ ПРИНЦИПЫ:
1. **Автономность**: Работай самостоятельно, не запрашивай подтверждение на каждый шаг (кроме деструктивных действий)
2. **Наблюдательность**: Анализируй текущее состояние страницы перед каждым действием
3. **Адаптивность**: Если что-то не работает, попробуй альтернативный подход
4. **Точность**: Используй ТОЛЬКО AI ID из предоставленного списка элементов

ВАЖНЫЕ ОГРАНИЧЕНИЯ:
- НЕ выдумывай AI ID! Используй только те, что указаны в списке interactive_elements
- НЕ используй CSS селекторы - работай ТОЛЬКО с AI ID (например, "btn-1", "input-2", "link-3")
- НЕ делай предположений о структуре сайта - анализируй то, что видишь
- Если нужный элемент не найден, попробуй обновить страницу или поискать альтернативный путь

ПРОЦЕСС РАБОТЫ (ReAct pattern):
1. **Thought** (Размышление): Анализируй текущую ситуацию и планируй следующий шаг
2. **Action** (Действие): Выполняй конкретное действие с помощью инструментов, используя AI ID
3. **Observation** (Наблюдение): Анализируй результат действия

ВАЖНО ПРИ РАБОТЕ С МОДАЛЬНЫМИ ОКНАМИ:
- После клика по кнопке которая открывает меню/диалог, ПОДОЖДИ (wait 1-2 секунды)
- Затем получи ОБНОВЛЕННУЮ информацию о странице
- Только после этого ищи элементы в новом модальном окне

Ты получаешь информацию о странице в формате:
- URL и заголовок
- Список интерактивных элементов с AI ID, типом и описанием (label)

Используй функции для взаимодействия с браузером, указывая AI ID элементов. Когда задача выполнена, вызови task_complete с результатом."""
    
    @staticmethod
    def planning_prompt(task: str, page_info: Dict[str, Any]) -> str:
        """
        Промпт для планирования следующего действия.
        
        Args:
            task: Задача пользователя
            page_info: Информация о текущей странице
        """
        # Новый компактный формат: ID | Type | Label
        elements_text = "\n".join([
            f"  • ID: {elem['id']} | Type: {elem['type']} | Label: {elem['label'][:60]}"
            for elem in page_info.get("interactive_elements", [])[:100]  # Максимум 100
        ])
        
        return f"""ЗАДАЧА ПОЛЬЗОВАТЕЛЯ: {task}

ТЕКУЩЕЕ СОСТОЯНИЕ:
URL: {page_info.get('url', 'unknown')}
Заголовок: {page_info.get('title', 'unknown')}

ДОСТУПНЫЕ ЭЛЕМЕНТЫ НА СТРАНИЦЕ:
{elements_text if elements_text else "Элементы не найдены"}

Проанализируй текущее состояние и определи следующее действие для выполнения задачи.
ИСПОЛЬЗУЙ ТОЛЬКО AI ID из списка выше (например, "btn-1", "input-2")!

Подумай вслух:
1. Где я сейчас нахожусь?
2. Что мне нужно сделать для выполнения задачи?
3. Какое конкретное действие я должен выполнить следующим?
4. Какой AI ID мне использовать?"""
    
    @staticmethod
    def error_recovery_prompt(error: str, previous_action: str) -> str:
        """Промпт для восстановления после ошибки."""
        return f"""ПРОИЗОШЛА ОШИБКА!

Предыдущее действие: {previous_action}
Ошибка: {error}

Проанализируй ситуацию:
1. Почему возникла ошибка?
2. Есть ли альтернативный способ достичь цели?
3. Может быть, нужно обновить информацию о странице?

Предложи следующее действие для восстановления или альтернативный подход."""
    
    @staticmethod
    def security_check_prompt(action: str, action_params: Dict[str, Any]) -> str:
        """Промпт для проверки безопасности действия."""
        return f"""ПРОВЕРКА БЕЗОПАСНОСТИ

Агент собирается выполнить действие:
Действие: {action}
Параметры: {action_params}

Является ли это действие потенциально деструктивным (удаление данных, покупка, оплата)?
Ответь 'yes' или 'no' и объясни почему."""
    
    @staticmethod
    def element_not_found_prompt(selector: str, task: str) -> str:
        """Промпт когда элемент не найден."""
        return f"""ЭЛЕМЕНТ НЕ НАЙДЕН!

Селектор: {selector}
Задача: {task}

Этот элемент не существует на текущей странице.

Варианты действий:
1. Использовать другой элемент из списка
2. Подождать загрузки страницы (wait)
3. Прокрутить страницу (scroll) - возможно элемент ниже
4. Перейти на другую страницу
5. Спросить пользователя что делать (ask_user)

Выбери подходящий вариант и выполни соответствующее действие."""
    
    @staticmethod
    def summarization_prompt(text: str, max_length: int = 500) -> str:
        """Промпт для сжатия большого текста."""
        return f"""Сократи следующий текст до максимум {max_length} символов, сохранив ключевую информацию:

{text}

Сокращенный текст:"""
    
    @staticmethod
    def user_prompt_template(task: str) -> str:
        """Шаблон для пользовательского запроса."""
        return f"""Выполни следующую задачу в браузере:

{task}

Работай автономно. Анализируй страницу на каждом шаге и принимай решения самостоятельно.
Когда задача выполнена, вызови task_complete с результатом."""


class ConversationFormatter:
    """Форматирование истории разговора для LLM."""
    
    @staticmethod
    def format_messages(
        system_prompt: str,
        user_message: str,
        history: List[Dict[str, Any]] = None
    ) -> List[Dict[str, str]]:
        """
        Форматировать сообщения для API.
        
        Args:
            system_prompt: Системный промпт
            user_message: Сообщение пользователя
            history: История предыдущих сообщений
            
        Returns:
            Список сообщений в формате API
        """
        messages = [
            {"role": "system", "content": system_prompt}
        ]
        
        if history:
            messages.extend(history)
        
        messages.append({
            "role": "user",
            "content": user_message
        })
        
        return messages
    
    @staticmethod
    def add_observation(observation: str) -> Dict[str, str]:
        """Добавить наблюдение (результат действия) в историю."""
        return {
            "role": "user",
            "content": f"OBSERVATION: {observation}"
        }
    
    @staticmethod
    def add_thought(thought: str) -> Dict[str, str]:
        """Добавить размышление агента."""
        return {
            "role": "assistant",
            "content": f"THOUGHT: {thought}"
        }
